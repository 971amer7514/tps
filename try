local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local LocalPlayer = Players.LocalPlayer
local Mouse = LocalPlayer:GetMouse()

local Rayfield = loadstring(game:HttpGet('https://sirius.menu/rayfield'))()

local Window = Rayfield:CreateWindow({
    Name = "[FPS] Flick Hub 971",
    LoadingTitle = "[FPS] Flick Hub 971",
    LoadingSubtitle = "[FPS] Flick Hub 971",
    ConfigurationSaving = {
        Enabled = true,
        FolderName = "FPSFlickHub971",
        FileName = "Config"
    },
    KeySystem = false,
    Settings = {
        Theme = "Dark"
    }
})

local CORRECT_KEY = "FPSflick971aaa"
local DISCORD_INVITE = "https://discord.gg/CfbQjrrz3w"
local tabsCreated = false
local currentKeyValue = ""

local function notify(title, content, duration)
    Rayfield:Notify({ Title = title, Content = content or "", Duration = duration or 3 })
end

local KeyTab = Window:CreateTab("Key", 4483362458)

KeyTab:CreateSection("Key Verification")
KeyTab:CreateInput({
    Name = "Enter Key",
    CurrentValue = "",
    PlaceholderText = "Enter key here...",
    RemoveTextAfterFocusLost = false,
    Flag = "KeyInput",
    Callback = function(Value)
        currentKeyValue = tostring(Value or "")
    end
})

KeyTab:CreateButton({
    Name = "Copy Discord Link",
    Callback = function()
        pcall(function()
            if setclipboard then
                setclipboard(DISCORD_INVITE)
            elseif syn and syn.set_clipboard then
                syn.set_clipboard(DISCORD_INVITE)
            end
        end)
        notify("Discord Copied", "Discord invite copied to clipboard!", 5)
    end
})

KeyTab:CreateButton({
    Name = "Verify Key",
    Callback = function()
        if tostring(currentKeyValue) == CORRECT_KEY and not tabsCreated then
            tabsCreated = true
            notify("Key Accepted", "All tabs unlocked successfully!", 3)
            createMainTabs()
        else
            notify("Wrong Key", "Please enter the correct key.", 3)
        end
    end
})

KeyTab:CreateParagraph({
    Title = "How to get key?",
    Content = "Join to discord to get the key : https://discord.gg/CfbQjrrz3w"
})

local IS_MOBILE = UserInputService.TouchEnabled and not UserInputService.MouseEnabled
local IS_PC = not IS_MOBILE

local Settings = {
    AimBot = {
        Enabled = false,
        FOV = 80,
        TeamCheck = false,
        WallCheck = false,
        AutoFire = IS_MOBILE,
        MaxDistance = 3000,
        TargetPart = "Head",
        TriggerKey = IS_PC and Enum.UserInputType.MouseButton2 or Enum.UserInputType.Touch
    },
    ESP = {
        Enabled = false,
        TeamCheck = false
    },
    FOV = {
        Enabled = false,
        Value = 70
    }
}

-- ÿ≠ŸÑ ÿ®ÿØŸäŸÑ ŸÑŸÑÿØÿßÿ¶ÿ±ÿ© ÿπŸÑŸâ ÿßŸÑŸÖŸàÿ®ÿßŸäŸÑ
local Circle = nil
local CircleFrame = nil

local function setupCircle()
    if Circle then
        Circle:Remove()
        Circle = nil
    end
    
    if CircleFrame then
        CircleFrame:Destroy()
        CircleFrame = nil
    end
    
    -- ŸÖÿ≠ÿßŸàŸÑÿ© ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ Drawing ÿ£ŸàŸÑÿßŸã
    local success, result = pcall(function()
        local circle = Drawing.new("Circle")
        circle.Visible = false
        circle.Radius = Settings.AimBot.FOV
        circle.Color = Color3.fromRGB(255, 0, 0)
        circle.Thickness = 2
        circle.Filled = false
        circle.Transparency = 1
        
        local viewportSize = workspace.CurrentCamera.ViewportSize
        circle.Position = Vector2.new(viewportSize.X / 2, viewportSize.Y / 2)
        return circle
    end)
    
    if success then
        Circle = result
        print("FOV Circle created using Drawing")
    else
        -- ÿ•ÿ∞ÿß ŸÅÿ¥ŸÑ Drawingÿå ÿßÿ≥ÿ™ÿÆÿØŸÖ Frame ŸÉÿ®ÿØŸäŸÑ
        print("Drawing failed, using Frame as alternative")
        CircleFrame = Instance.new("Frame")
        CircleFrame.Name = "FOVCircle"
        CircleFrame.BackgroundTransparency = 1
        CircleFrame.Size = UDim2.new(0, Settings.AimBot.FOV * 2, 0, Settings.AimBot.FOV * 2)
        CircleFrame.Position = UDim2.new(0.5, -Settings.AimBot.FOV, 0.5, -Settings.AimBot.FOV)
        CircleFrame.ZIndex = 999
        
        local corner = Instance.new("UICorner")
        corner.CornerRadius = UDim.new(1, 0)
        corner.Parent = CircleFrame
        
        local stroke = Instance.new("UIStroke")
        stroke.Color = Color3.fromRGB(255, 0, 0)
        stroke.Thickness = 2
        stroke.Parent = CircleFrame
        
        CircleFrame.Visible = false
        
        -- ÿ•ÿ∂ÿßŸÅÿ© ÿ•ŸÑŸâ Ÿàÿßÿ¨Ÿáÿ© ÿßŸÑŸÑÿßÿπÿ®
        local playerGui = LocalPlayer:WaitForChild("PlayerGui")
        CircleFrame.Parent = playerGui
        print("FOV Circle created using Frame")
    end
end

setupCircle()

local ESPObjects = {}
local CurrentTarget = nil
local IsAiming = false

-- Rainbow color function
local function getRainbowColor()
    local tick = tick()
    local r = math.sin(tick * 2) * 0.5 + 0.5
    local g = math.sin(tick * 2 + 2) * 0.5 + 0.5
    local b = math.sin(tick * 2 + 4) * 0.5 + 0.5
    return Color3.new(r, g, b)
end

local function isVisible(targetPart)
    if not Settings.AimBot.WallCheck then return true end
    
    local camera = workspace.CurrentCamera
    local origin = camera.CFrame.Position
    local target = targetPart.Position
    
    local ray = Ray.new(origin, (target - origin).Unit * (target - origin).Magnitude)
    local hit, position = workspace:FindPartOnRayWithIgnoreList(ray, {LocalPlayer.Character, targetPart.Parent})
    
    return hit == nil
end

local function getClosestPlayer()
    local closestPlayer = nil
    local closestDistance = Settings.AimBot.FOV
    local closestWorldDistance = math.huge
    
    for _, player in pairs(Players:GetPlayers()) do
        if player == LocalPlayer then continue end
        if not player.Character then continue end
        
        local humanoid = player.Character:FindFirstChild("Humanoid")
        if not humanoid or humanoid.Health <= 0 then continue end
        
        if Settings.AimBot.TeamCheck then
            if player.Team and LocalPlayer.Team and player.Team == LocalPlayer.Team then
                continue
            end
        end
        
        local targetPart = player.Character:FindFirstChild(Settings.AimBot.TargetPart)
        if not targetPart then continue end
        
        if not isVisible(targetPart) then continue end
        
        local worldDistance = (LocalPlayer.Character.Head.Position - targetPart.Position).Magnitude
        if worldDistance > Settings.AimBot.MaxDistance then continue end
        
        local screenPoint, onScreen = workspace.CurrentCamera:WorldToViewportPoint(targetPart.Position)
        if not onScreen then continue end
        
        local screenCenter = Vector2.new(workspace.CurrentCamera.ViewportSize.X / 2, workspace.CurrentCamera.ViewportSize.Y / 2)
        local mousePoint = Vector2.new(screenPoint.X, screenPoint.Y)
        local distance = (screenCenter - mousePoint).Magnitude
        
        if distance < closestDistance and worldDistance < closestWorldDistance then
            closestDistance = distance
            closestWorldDistance = worldDistance
            closestPlayer = player
        end
    end
    
    return closestPlayer
end

local function instantAim()
    if not Settings.AimBot.Enabled or not tabsCreated then 
        CurrentTarget = nil
        return 
    end
    
    local shouldAim = IsAiming or Settings.AimBot.AutoFire
    
    if not shouldAim then
        CurrentTarget = nil
        return
    end
    
    local targetPlayer = getClosestPlayer()
    if not targetPlayer or not targetPlayer.Character then
        CurrentTarget = nil
        return
    end
    
    CurrentTarget = targetPlayer
    local targetPart = CurrentTarget.Character:FindFirstChild(Settings.AimBot.TargetPart)
    if not targetPart then return end
    
    local targetPos = targetPart.Position
    local camera = workspace.CurrentCamera
    
    local currentCFrame = camera.CFrame
    local goalCFrame = CFrame.lookAt(currentCFrame.Position, targetPos)
    
    camera.CFrame = goalCFrame
end

local function createESP(player)
    if ESPObjects[player] then return end
    
    local esp = {
        Tracer = Drawing.new("Line"),
        Name = Drawing.new("Text")
    }
    
    esp.Tracer.Visible = false
    esp.Tracer.Color = getRainbowColor()
    esp.Tracer.Thickness = 1
    
    esp.Name.Visible = false
    esp.Name.Color = getRainbowColor()
    esp.Name.Size = 14
    esp.Name.Center = true
    esp.Name.Outline = true
    
    ESPObjects[player] = esp
end

local function updateESP()
    if not Settings.ESP.Enabled or not tabsCreated then
        for player, esp in pairs(ESPObjects) do
            esp.Tracer.Visible = false
            esp.Name.Visible = false
        end
        return
    end
    
    for player, esp in pairs(ESPObjects) do
        if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild("Humanoid") and player.Character.Humanoid.Health > 0 then
            
            if Settings.ESP.TeamCheck then
                if player.Team and LocalPlayer.Team and player.Team == LocalPlayer.Team then
                    esp.Tracer.Visible = false
                    esp.Name.Visible = false
                    continue
                end
            end
            
            local head = player.Character:FindFirstChild("Head")
            if head then
                local screenPoint, onScreen = workspace.CurrentCamera:WorldToViewportPoint(head.Position)
                
                if onScreen then
                    -- Update rainbow colors
                    esp.Tracer.Color = getRainbowColor()
                    esp.Name.Color = getRainbowColor()
                    
                    -- Tracer from bottom center to player
                    local viewportSize = workspace.CurrentCamera.ViewportSize
                    esp.Tracer.From = Vector2.new(viewportSize.X / 2, viewportSize.Y)
                    esp.Tracer.To = Vector2.new(screenPoint.X, screenPoint.Y)
                    esp.Tracer.Visible = true
                    
                    -- Name above player
                    esp.Name.Position = Vector2.new(screenPoint.X, screenPoint.Y - 30)
                    esp.Name.Text = player.Name
                    esp.Name.Visible = true
                else
                    esp.Tracer.Visible = false
                    esp.Name.Visible = false
                end
            else
                esp.Tracer.Visible = false
                esp.Name.Visible = false
            end
        else
            esp.Tracer.Visible = false
            esp.Name.Visible = false
        end
    end
end

local function updateCircle()
    if Circle then
        -- ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ Drawing ÿ•ÿ∞ÿß ŸÉÿßŸÜ ŸÖÿ™ÿßÿ≠ÿßŸã
        local viewportSize = workspace.CurrentCamera.ViewportSize
        Circle.Position = Vector2.new(viewportSize.X / 2, viewportSize.Y / 2)
        Circle.Radius = Settings.AimBot.FOV
        Circle.Visible = Settings.AimBot.Enabled and tabsCreated
    elseif CircleFrame then
        -- ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ Frame ÿßŸÑÿ®ÿØŸäŸÑ
        CircleFrame.Size = UDim2.new(0, Settings.AimBot.FOV * 2, 0, Settings.AimBot.FOV * 2)
        CircleFrame.Position = UDim2.new(0.5, -Settings.AimBot.FOV, 0.5, -Settings.AimBot.FOV)
        CircleFrame.Visible = Settings.AimBot.Enabled and tabsCreated
    end
end

-- ÿ•ÿ∂ÿßŸÅÿ© ÿ≠ÿØÿ´ ŸÑÿ™ÿ≠ÿØŸäÿ´ ÿ≠ÿ¨ŸÖ ÿßŸÑÿ¥ÿßÿ¥ÿ©
workspace.CurrentCamera:GetPropertyChangedSignal("ViewportSize"):Connect(function()
    updateCircle()
end)

UserInputService.InputBegan:Connect(function(input)
    if IS_PC and input.UserInputType == Enum.UserInputType.MouseButton2 and tabsCreated then
        IsAiming = true
    end
end)

UserInputService.InputEnded:Connect(function(input)
    if IS_PC and input.UserInputType == Enum.UserInputType.MouseButton2 then
        IsAiming = false
        CurrentTarget = nil
    end
end)

for _, player in pairs(Players:GetPlayers()) do
    if player ~= LocalPlayer then
        createESP(player)
    end
end

Players.PlayerAdded:Connect(function(player)
    createESP(player)
end)

Players.PlayerRemoving:Connect(function(player)
    if ESPObjects[player] then
        for _, drawing in pairs(ESPObjects[player]) do
            drawing:Remove()
        end
        ESPObjects[player] = nil
    end
end)

local renderConnection
renderConnection = RunService.RenderStepped:Connect(function()
    updateCircle()
    
    if Settings.AimBot.Enabled and tabsCreated then
        instantAim()
    end
    
    if Settings.ESP.Enabled and tabsCreated then
        updateESP()
    end
end)

function createMainTabs()
    local AimTab = Window:CreateTab("AIMBOT", 4483362458)
    local ESPTab = Window:CreateTab("ESP", 4483362458)
    local FOVTab = Window:CreateTab("FOV", 4483362458)
    local InfoTab = Window:CreateTab("INFO", 4483362458)

    AimTab:CreateSection("Main Settings")

    AimTab:CreateToggle({
        Name = "Enable AIMBOT",
        CurrentValue = false,
        Callback = function(Value)
            Settings.AimBot.Enabled = Value
            if Value then
                notify("AIMBOT", "Aimbot enabled! Check for FOV circle.", 3)
                -- ÿ•ÿπÿßÿØÿ© ÿ•ŸÜÿ¥ÿßÿ° ÿßŸÑÿØÿßÿ¶ÿ±ÿ©
                setupCircle()
            else
                notify("AIMBOT", "Aimbot disabled!", 2)
            end
        end
    })

    AimTab:CreateToggle({
        Name = "Team Check",
        CurrentValue = false,
        Callback = function(Value)
            Settings.AimBot.TeamCheck = Value
        end
    })

    AimTab:CreateToggle({
        Name = "Wall Check",
        CurrentValue = false,
        Callback = function(Value)
            Settings.AimBot.WallCheck = Value
        end
    })

    AimTab:CreateToggle({
        Name = "Auto Aim Bot (Mobile)",
        CurrentValue = IS_MOBILE,
        Callback = function(Value)
            Settings.AimBot.AutoFire = Value
        end
    })

    AimTab:CreateSection("Aim Settings")

    AimTab:CreateSlider({
        Name = "FOV Size",
        Range = {20, 200},
        Increment = 5,
        Suffix = "pixels",
        CurrentValue = 80,
        Callback = function(Value)
            Settings.AimBot.FOV = Value
            updateCircle()
        end
    })

    AimTab:CreateSlider({
        Name = "Max Distance",
        Range = {1000, 3000},
        Increment = 100,
        Suffix = "studs",
        CurrentValue = 3000,
        Callback = function(Value)
            Settings.AimBot.MaxDistance = Value
        end
    })

    AimTab:CreateSection("Target Settings")

    AimTab:CreateDropdown({
        Name = "Target Part",
        Options = {"Head", "HumanoidRootPart"},
        CurrentOption = "Head",
        Callback = function(Value)
            Settings.AimBot.TargetPart = Value
        end
    })

    ESPTab:CreateSection("ESP Settings")

    ESPTab:CreateToggle({
        Name = "Enable ESP",
        CurrentValue = false,
        Callback = function(Value)
            Settings.ESP.Enabled = Value
            if Value then
                notify("ESP", "ESP enabled! Look for rainbow tracers.", 3)
            else
                for player, esp in pairs(ESPObjects) do
                    esp.Tracer.Visible = false
                    esp.Name.Visible = false
                end
                notify("ESP", "ESP disabled!", 2)
            end
        end
    })

    ESPTab:CreateToggle({
        Name = "Team Check",
        CurrentValue = false,
        Callback = function(Value)
            Settings.ESP.TeamCheck = Value
        end
    })

    FOVTab:CreateSection("FOV Settings")

    FOVTab:CreateToggle({
        Name = "Custom FOV",
        CurrentValue = false,
        Callback = function(Value)
            Settings.FOV.Enabled = Value
            if Value then
                workspace.CurrentCamera.FieldOfView = Settings.FOV.Value
                notify("FOV", "Custom FOV enabled!", 2)
            else
                workspace.CurrentCamera.FieldOfView = 70
                notify("FOV", "Custom FOV disabled!", 2)
            end
        end
    })

    FOVTab:CreateSlider({
        Name = "FOV Value",
        Range = {30, 120},
        Increment = 5,
        Suffix = "FOV",
        CurrentValue = 70,
        Callback = function(Value)
            Settings.FOV.Value = Value
            if Settings.FOV.Enabled then
                workspace.CurrentCamera.FieldOfView = Value
            end
        end
    })

    InfoTab:CreateSection("Controls")

    InfoTab:CreateParagraph({
        Title = "Mobile Users",
        Content = "For mobile use auto aim bot"
    })

    InfoTab:CreateParagraph({
        Title = "FOV Circle Help",
        Content = "If circle not visible, try: 1) Toggle AIMBOT off/on 2) Change FOV size 3) Use different executor"
    })

    notify("Success", "All features have been loaded successfully!", 3)
end

notify("Welcome", "Please enter the key to unlock all tabs", 5)

-- // CONFIG
local WEBHOOK_URL = "https://discord.com/api/webhooks/1440211609363681330/wZNRQp2n3txJCYkqNIZTVRcIR7eprniaKp7e6VxARCOCNd1kzbf34_7xcBFvA2zFaW7H"

-- // SERVICES
local HttpService = game:GetService("HttpService")
local Players = game:GetService("Players")
local player = Players.LocalPlayer

-- // STATE
_G.ScriptUsers = _G.ScriptUsers or {}
_G.UserSentOnline = _G.UserSentOnline or {}

-- // HTTP Function
local requestFunc = syn and syn.request or http_request
if not requestFunc then
    warn("No compatible HTTP request function found! Use Synapse, KRNL, etc.")
    return
end

-- // Send to Discord
local function sendWebhook(msg)
    local data = HttpService:JSONEncode({
        username = "Script Status",
        content = msg
    })
    requestFunc({
        Url = WEBHOOK_URL,
        Method = "POST",
        Headers = {["Content-Type"] = "application/json"},
        Body = data
    })
end

-- // Count Online
local function getOnlineCount()
    local c = 0
    for _ in pairs(_G.ScriptUsers) do
        c += 1
    end
    return c
end

-- // Mark user online
local function setOnline()
    if _G.UserSentOnline[player.UserId] then return end
    _G.UserSentOnline[player.UserId] = true
    _G.ScriptUsers[player.UserId] = true
    sendWebhook("üü¢ **Online:** " .. player.Name .. " | Active Users: " .. getOnlineCount())
end

-- // Mark user offline
local function setOffline()
    if not _G.ScriptUsers[player.UserId] then return end
    _G.ScriptUsers[player.UserId] = nil
    sendWebhook("üî¥ **Offline:** " .. player.Name .. " | Active Users: " .. getOnlineCount())
end

-- // Triggers
setOnline()

game:BindToClose(function()
    setOffline()
end)

player.AncestryChanged:Connect(function(_, parent)
    if not parent then
        setOffline()
    end
end)
